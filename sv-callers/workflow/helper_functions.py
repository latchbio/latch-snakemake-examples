"""Helper functions."""
import os

from csv import DictReader
from validator import load_configfile

config_path = "../config"
config = load_configfile(os.path.join(config_path, "analysis.yaml"))


def get_fasta():
    """
    Get reference genome in FASTA format.

    :returns: filepath
    """
    fname = config.genome
    if not os.path.exists(fname):
        raise FileNotFoundError("FASTA file '{}' not found.".format(fname))
    if not fname.endswith(config.file_exts.fasta):
        raise ValueError("FASTA file extension '{}' not registered.".format(
            os.path.splitext(fname)[-1]))
    if os.path.getsize(fname) == 0:
        raise OSError("FASTA file '{}' is empty.".format(fname))
    return fname


def get_faidx():
    """Get FASTA index files generated by faidx and bwa tools.
    :returns: (list) filepaths
    """
    faidx = []
    for sfx in config.file_exts.fasta_idx:
        fname = os.path.splitext(config.genome)[0] + sfx
        if not os.path.exists(fname):
            raise FileNotFoundError("FASTA index file '{}' not found.".format(fname))
        if os.path.getsize(fname) == 0:
            raise OSError("FASTA index file '{}' is empty.".format(fname))
        faidx.append(fname)
    return faidx


def exclude_regions():
    """Use an exclusion list of genomic regions in BED format.
    :returns: (int) flag 1=yes, 0=no
    """
    flag = config.exclude_regions
    if flag not in (0, 1):
        raise ValueError("Set 'exclude_regions' to either 0 or 1.")
    return flag


def get_bed():
    """Get the exclusion file in BED format.
    :returns: (str) filepath
    """
    fname = config.exclusion_list
    sfx = config.file_exts.bed
    if not os.path.exists(fname):
        raise FileNotFoundError("BED file '{}' with excluded regions not found."
            .format(fname))
    if not fname.endswith(sfx):
        raise ValueError("BED file extension '{}' not registered."
            .format(os.path.splitext(fname)[-1]))
    if os.path.getsize(fname) == 0:
        raise OSError("BED file '{}' is empty.".format(fname))
    return fname


def get_bam(sample):
    """Get the sample in BAM format.
    :param sample: (str) sample name
    :returns: (str) filepath
    """
    sfx = config.file_exts.bam
    if sample.endswith(sfx) is False:
        sample += sfx
    return sample


def get_bai(sample):
    """Get the index of sample in BAI format.
    :param sample: (str) sample name
    :returns: (str) filepath
    """
    sfx = config.file_exts.bam_idx
    if sample.endswith(sfx) is False:
        sample += sfx
    return sample


def get_outdir(tool):
    """Get the output directory of a tool.
    :param tool: (str) SV caller or post-processing tool
    :returns: (str) outdir relative to sample dir
    """
    cf = dict(manta=config.callers.manta.outdir,
              delly=config.callers.delly.outdir,
              lumpy=config.callers.lumpy.outdir,
              gridss=config.callers.gridss.outdir,
              survivor=config.postproc.survivor.outdir)
    return cf[tool]


def file_is_empty(filepath):
    """Raise error if the input file is empty.
    :param filepath (str) input file
    """
    if os.path.getsize(filepath) == 0:
        raise OSError("File '{}' is empty.".format(filepath))


def is_tumor_only():
    """Perform tumor-only or germline analysis using Manta.
    :returns: (int) flag 1=yes, 0=no
    """
    flag = config.callers.manta.tumor_only
    if flag not in (0, 1):
        raise ValueError("Set 'tumor_only' for Manta to either 0 or 1.")
    return flag


def survivor_args(c):
    """Get user-defined parameters for SURVIVOR command.
    :param c: sub-command 'filter' or 'merge'
    :returns: (list) arguments or values
    """
    cf = dict(filter = config.postproc.survivor.filter,
              merge = config.postproc.survivor.merge)
    p = cf[c]
    if c in "filter":
        return ['"%s"' % get_bed(), p.min_size, p.max_size, p.min_freq,
                p.min_sup]
    return [p.infile, p.max_dist, p.min_sup, p.use_type, p.use_strand,
                p.use_size, p.min_size, p.outfile]


def make_output():
    """Generate workflow targets: outfiles of different callers in VCF format.
    :returns: (list) filepaths:
        PATH/SAMPLE1/CALLER_OUTDIR/*.vcf           # in single-sample mode
        PATH/SAMPLE1--SAMPLE2/CALLER_OUTDIR/*.vcf  # in paired-sample mode
    """
    csvfile = os.path.join(config_path, config.samples)
    notvalid = (None, "")
    with open(csvfile, "r") as csv:
        outfiles = []
        for i, r in enumerate(DictReader(csv)):
            if "PATH" not in r or r["PATH"] in notvalid:
                raise ValueError("Missing column 'PATH' or value in '{}'."
                    .format(csvfile))
            if r["PATH"].startswith("#"):  # skip comment lines
                continue
            if "SAMPLE1" not in r or r["SAMPLE1"] in notvalid:
                raise ValueError("Missing column 'SAMPLE1' or value in '{}'."
                    .format(csvfile))
            for f in (get_bam(r["SAMPLE1"]), get_bai(r["SAMPLE1"])):
                file_is_empty(os.path.join(r["PATH"], f))
            path = os.path.join(r["PATH"], r["SAMPLE1"])

            if config.mode is config.mode.PAIRED_SAMPLE:
                if "SAMPLE2" not in r or r["SAMPLE2"] in notvalid:
                    raise ValueError("Missing column 'SAMPLE2' or value in '{}'."
                        .format(csvfile))
                for f in (get_bam(r["SAMPLE2"]), get_bai(r["SAMPLE2"])):
                    file_is_empty(os.path.join(r["PATH"], f))
                path += "--" + r["SAMPLE2"]
            for c in config.enable_callers:
                vcf = os.path.join(path, get_outdir(c), "survivor",
                    c + config.file_exts.vcf)
                outfiles.append(vcf)
        return outfiles


def make_all():
    """Generate workflow targets: outfiles of merged SV calls in VCF format.
    :returns: (list) filepaths:
        PATH/SAMPLE1/*.vcf           # in single-sample mode
        PATH/SAMPLE1--SAMPLE2/*.vcf  # in paired-sample mode
    """
    outfiles = []
    basename = survivor_args("merge")[-1]
    for f in make_output():
        path = os.path.join(os.sep.join(f.split(os.sep)[:-3]), basename)
        outfiles.append(path)
    return set(outfiles)
